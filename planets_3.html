<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            font-family: Arial, sans-serif;
            border-radius: 5px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="info">Left-click: Rotate | Right-click: Pan | Scroll: Zoom</div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.min.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ðŸŒŒ SCENE, CAMERA, RENDERER
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // ðŸŽ® ORBIT CONTROLS
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Add smooth damping effect
        controls.dampingFactor = 0.05;
        controls.rotateSpeed = 0.5;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.minDistance = 5; // Minimum zoom distance
        controls.maxDistance = 500; // Maximum zoom distance

        // ðŸ”½ Load Textures
        const textureLoader = new THREE.TextureLoader();
        const textures = {
            // Original textures
            earth: textureLoader.load('https://threejs.org/examples/textures/land_ocean_ice_cloud_2048.jpg'),
            moon: textureLoader.load('https://3dtextures.me/wp-content/uploads/2017/12/material_279.png'),
            mars: textureLoader.load('https://www.solarsystemscope.com/textures/download/8k_mars.jpg'),
            sun: textureLoader.load('https://upload.wikimedia.org/wikipedia/commons/3/3a/Solar_surface_texture.png'),
            saturn: textureLoader.load('https://upload.wikimedia.org/wikipedia/commons/6/63/Saturn-true-color.jpg'),
            jupiter: textureLoader.load('https://upload.wikimedia.org/wikipedia/commons/e/e2/Jupiter.jpg'),
            uranus: textureLoader.load('https://upload.wikimedia.org/wikipedia/commons/3/3d/Uranus.jpg'),
            neptune: textureLoader.load('https://upload.wikimedia.org/wikipedia/commons/0/06/Neptune.jpg'),
            saturnRings: textureLoader.load('https://upload.wikimedia.org/wikipedia/commons/3/36/Saturn_Rings_PIA06175.jpg'),
            
            // Enhanced textures for Sun
            sunNormal: textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_normal_2048.jpg'),
            sunEmissive: textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/lava/lavatile.jpg'),
            
            // Enhanced textures for Earth
            earthNormal: textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_normal_2048.jpg'),
            earthSpecular: textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg'),
            earthClouds: textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_clouds_2048.png'),
            
            // Enhanced textures for Moon
            moonNormal: textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/moon_normal.jpg'),
        };

        // Add loading error handling for Saturn rings texture
        textures.saturnRings.onLoad = function() {
            console.log("Saturn rings texture loaded successfully");
        };
        
        textures.saturnRings.onError = function() {
            console.error("Error loading Saturn rings texture");
        };

        // ðŸŒŸ DYNAMIC STAR FIELD
        const starCount = 10000;
        const starGeometry = new THREE.BufferGeometry();
        const starMaterial = new THREE.PointsMaterial({
            color: 0xFFFFFF,
            size: 0.1,
            transparent: true,
            opacity: 0.8,
            sizeAttenuation: true
        });

        // Create the vertices for stars
        const positions = new Float32Array(starCount * 3);
        const velocities = new Float32Array(starCount);

        for (let i = 0; i < starCount * 3; i += 3) {
            const radius = Math.random() * 2000 + 1000;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            
            positions[i] = radius * Math.sin(phi) * Math.cos(theta);
            positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
            positions[i + 2] = radius * Math.cos(phi);
            
            velocities[i / 3] = Math.random() * 0.5 + 0.1;
        }

        starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const starField = new THREE.Points(starGeometry, starMaterial);
        scene.add(starField);

        // ðŸŒž ENHANCED SUN
        const sunGeometry = new THREE.SphereGeometry(15, 64, 64);
        const sunMaterial = new THREE.MeshStandardMaterial({
            map: textures.sun,
            normalMap: textures.sunNormal,
            emissiveMap: textures.sunEmissive,
            emissive: 0xffaa00,
            emissiveIntensity: 2,
            roughness: 0.6,
            metalness: 0
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);

        // ðŸŒž Sun Light
        const sunlight = new THREE.PointLight(0xffdd55, 50, 4000);
        scene.add(sunlight);

        // PLANET CREATION FUNCTION
        function createPlanet(size, texture, distance) {
            const geometry = new THREE.SphereGeometry(size, 64, 64);
            const material = new THREE.MeshStandardMaterial({ map: texture });
            const planet = new THREE.Mesh(geometry, material);
            const orbit = new THREE.Group();
            orbit.position.x = distance;
            orbit.add(planet);
            scene.add(orbit);
            return { planet, orbit };
        }

        // ðŸŒ ENHANCED EARTH & MOON
        const earthGeometry = new THREE.SphereGeometry(1, 64, 64);
        const earthMaterial = new THREE.MeshPhongMaterial({
            map: textures.earth,
            normalMap: textures.earthNormal,
            specularMap: textures.earthSpecular,
            specular: new THREE.Color(0x333333),
            shininess: 25
        });
        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        const earthOrbit = new THREE.Group();
        earthOrbit.position.x = 20;
        earthOrbit.add(earth);
        scene.add(earthOrbit);
        const earthData = { planet: earth, orbit: earthOrbit };

        // Earth Clouds
        const earthCloudGeometry = new THREE.SphereGeometry(1.01, 64, 64);
        const earthCloudMaterial = new THREE.MeshPhongMaterial({
            map: textures.earthClouds,
            transparent: true,
            opacity: 0.4
        });
        const earthClouds = new THREE.Mesh(earthCloudGeometry, earthCloudMaterial);
        earth.add(earthClouds);

        // ðŸŒ‘ ENHANCED MOON
        const moonGeometry = new THREE.SphereGeometry(0.27, 64, 64);
        const moonMaterial = new THREE.MeshPhongMaterial({
            map: textures.moon,
            normalMap: textures.moonNormal,
            roughness: 1,
            metalness: 0
        });
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        const moonOrbit = new THREE.Group();
        moonOrbit.position.x = 2.5;
        moonOrbit.add(moon);
        earth.add(moonOrbit);
        const moonData = { planet: moon, orbit: moonOrbit };

        // ðŸ”´ MARS
        const marsData = createPlanet(0.8, textures.mars, 30);

        // ðŸª SATURN
        const saturnData = createPlanet(3, textures.saturn, 60);

        // SATURN RINGS - IMPROVED
        const ringGeometry = new THREE.RingGeometry(3.5, 7, 64);
        
        // Create vertex position attribute for the ring
        const position = ringGeometry.attributes.position;
        const vertex = new THREE.Vector3();
        // Generate UVs properly for the ring texture
        const uv = new Float32Array(position.count * 2);

        for (let i = 0; i < position.count; i++) {
            vertex.fromBufferAttribute(position, i);
            const u = (vertex.x / 7 + 0.5); // normalize x to 0-1 range
            const v = (vertex.y / 7 + 0.5); // normalize y to 0-1 range
            uv[i * 2] = u;
            uv[i * 2 + 1] = v;
        }

        ringGeometry.setAttribute('uv', new THREE.BufferAttribute(uv, 2));

        const ringMaterial = new THREE.MeshStandardMaterial({
            map: textures.saturnRings,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.9,
            roughness: 0.7,
            metalness: 0.2
        });

        const saturnRings = new THREE.Mesh(ringGeometry, ringMaterial);
        saturnRings.rotation.x = Math.PI / 2; // Rotate to make rings horizontal
        saturnData.planet.add(saturnRings);
        saturnRings.visible = true;

        // ðŸŒ€ JUPITER
        const jupiterData = createPlanet(4, textures.jupiter, 80);

        // â„ï¸ URANUS
        const uranusData = createPlanet(2.5, textures.uranus, 100);

        // ðŸŒŠ NEPTUNE
        const neptuneData = createPlanet(2.5, textures.neptune, 120);

        // ðŸ”… AMBIENT LIGHT
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        // ðŸŽ¥ CAMERA POSITION
        camera.position.set(0, 30, 100);  // Adjusted for better initial view

        // ðŸ”„ ANIMATION
        let angle = 0;
        function animate() {
            requestAnimationFrame(animate);
            
            // Update controls
            controls.update();

            // Update star positions
            const positions = starField.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i + 2] += velocities[i / 3];
                if (positions[i + 2] > 1000) {
                    positions[i + 2] = -2000;
                }
            }
            starField.geometry.attributes.position.needsUpdate = true;

            // ROTATIONS
            sun.rotation.y += 0.002;
            earthData.planet.rotation.y += 0.005;
            if (earthClouds) earthClouds.rotation.y += 0.006; // Clouds rotate slightly faster
            marsData.planet.rotation.y += 0.005;
            saturnData.planet.rotation.y += 0.005;
            jupiterData.planet.rotation.y += 0.005;
            uranusData.planet.rotation.y += 0.005;
            neptuneData.planet.rotation.y += 0.005;

            // ORBIT MOVEMENT
            angle += 0.002;
            earthData.orbit.position.x = Math.cos(angle) * 20;
            earthData.orbit.position.z = Math.sin(angle) * 20;

            moonData.orbit.position.x = Math.cos(angle * 5) * 2.5;
            moonData.orbit.position.z = Math.sin(angle * 5) * 2.5;

            marsData.orbit.position.x = Math.cos(angle * 0.8) * 30;
            marsData.orbit.position.z = Math.sin(angle * 0.8) * 30;

            saturnData.orbit.position.x = Math.cos(angle * 0.6) * 60;
            saturnData.orbit.position.z = Math.sin(angle * 0.6) * 60;

            jupiterData.orbit.position.x = Math.cos(angle * 0.4) * 80;
            jupiterData.orbit.position.z = Math.sin(angle * 0.4) * 80;

            uranusData.orbit.position.x = Math.cos(angle * 0.3) * 100;
            uranusData.orbit.position.z = Math.sin(angle * 0.3) * 100;

            neptuneData.orbit.position.x = Math.cos(angle * 0.2) * 120;
            neptuneData.orbit.position.z = Math.sin(angle * 0.2) * 120;

            renderer.render(scene, camera);
        }
        animate();

        // ðŸ“ RESIZE HANDLING
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

    </script>
</body>
</html>