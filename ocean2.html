<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Underwater Scene with Improved Surface</title>
    <style>
        body { 
            margin: 0; 
            overflow-x: hidden; 
            height: 500vh; /* Allow scrolling for depth effect */
            background: linear-gradient(to bottom, #87CEEB, #001020);
            font-family: Arial, sans-serif;
        }
        canvas { 
            display: block; 
            position: fixed;
            top: 0;
            left: 0;
        }
        .instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            z-index: 100;
        }
        .depth-marker {
            position: fixed;
            right: 20px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            z-index: 100;
        }
        .tooltip {
            position: fixed;
            display: none;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            z-index: 200;
            pointer-events: none;
            max-width: 250px;
        }
    </style>
    <!-- Load GSAP via CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>
<div class="instructions">Scroll to dive deeper. Click on the fisherman to cast the line. Hover over fish for information.</div>
<div class="depth-marker">Current Depth: 0m</div>
<div class="tooltip"></div>

<script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.js";

    // Scene, Camera, Renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Tooltip setup
    const tooltip = document.querySelector('.tooltip');
    const depthMarker = document.querySelector('.depth-marker');

    // Raycaster for fish tooltip interaction
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // Texture Loader
    const textureLoader = new THREE.TextureLoader();
    
    // Load Textures
    const waterTexture = textureLoader.load('https://i.ibb.co/JKKrwq2/water-normal.jpg');
    waterTexture.wrapS = THREE.RepeatWrapping;
    waterTexture.wrapT = THREE.RepeatWrapping;
    waterTexture.repeat.set(5, 5);
    
    const sandTexture = textureLoader.load('https://i.ibb.co/KrgSZS1/sand-texture.jpg');
    sandTexture.wrapS = THREE.RepeatWrapping;
    sandTexture.wrapT = THREE.RepeatWrapping;
    sandTexture.repeat.set(10, 10);
    
    const woodTexture = textureLoader.load('https://i.ibb.co/MCn3BWy/wood-texture.jpg');
    
    // Sky (visible from boat)
    const skyGeometry = new THREE.SphereGeometry(200, 32, 32);
    const skyMaterial = new THREE.MeshBasicMaterial({
        color: 0x87CEEB,
        side: THREE.BackSide
    });
    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(sky);
    
    // Sun (daylight effect)
    const sunGeometry = new THREE.SphereGeometry(10, 32, 32);
    const sunMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffcc,
        transparent: true,
        opacity: 0.8
    });
    const sun = new THREE.Mesh(sunGeometry, sunMaterial);
    sun.position.set(50, 80, -100);
    scene.add(sun);
    
    // Sunlight glow effect
    const sunLight = new THREE.PointLight(0xffffcc, 1, 300);
    sunLight.position.copy(sun.position);
    scene.add(sunLight);

    // Fog (Darker as we go deeper)
    scene.fog = new THREE.FogExp2(0x1e3a5f, 0.04);
    renderer.setClearColor(scene.fog.color);

    // Lights
    const ambientLight = new THREE.AmbientLight(0x333333);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffcc, 1);
    directionalLight.position.set(0, 10, 5);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;
    scene.add(directionalLight);
    
    // Create distinct surface and underwater zones
    
    // Water surface with normal map and transparency
    const waterGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
    const waterMaterial = new THREE.MeshPhysicalMaterial({ 
        color: 0x0099ff,
        transparent: true, 
        opacity: 0.8,
        normalMap: waterTexture,
        normalScale: new THREE.Vector2(0.5, 0.5),
        metalness: 0.1,
        roughness: 0.4,
        transmission: 0.5,
        reflectivity: 0.5
    });
    const waterSurface = new THREE.Mesh(waterGeometry, waterMaterial);
    waterSurface.rotation.x = -Math.PI / 2;
    waterSurface.position.y = 0;
    scene.add(waterSurface);
    
    // Surface water effect (waves)
    const surfaceGeometry = new THREE.PlaneGeometry(200, 200, 128, 128);
    const surfaceVertices = surfaceGeometry.attributes.position.array;
    const surfaceMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x99ccff,
        transparent: true,
        opacity: 0.3,
        metalness: 0,
        roughness: 0.2,
        transmission: 0.9
    });
    const surfaceWater = new THREE.Mesh(surfaceGeometry, surfaceMaterial);
    surfaceWater.rotation.x = -Math.PI / 2;
    surfaceWater.position.y = 0.1;
    scene.add(surfaceWater);

    // Ocean Body (volumetric water effect)
    const oceanBodyGeometry = new THREE.BoxGeometry(200, 40, 200);
    const oceanBodyMaterial = new THREE.MeshStandardMaterial({
        color: 0x0066aa,
        transparent: true,
        opacity: 0.3
    });
    const oceanBody = new THREE.Mesh(oceanBodyGeometry, oceanBodyMaterial);
    oceanBody.position.y = -20; // Center of the ocean volume
    scene.add(oceanBody);

    // Ocean Floor with texture
    const oceanFloor = new THREE.Mesh(
        new THREE.PlaneGeometry(200, 200, 32, 32),
        new THREE.MeshStandardMaterial({ 
            color: 0xddddcc, 
            map: sandTexture,
            roughness: 1,
            metalness: 0
        })
    );
    oceanFloor.rotation.x = -Math.PI / 2;
    oceanFloor.position.y = -1000; // Set to 1km depth
    oceanFloor.receiveShadow = true;
    scene.add(oceanFloor);

    // Create Boat with Wood Texture that floats on surface
    const createBoat = () => {
        const boatGroup = new THREE.Group();
        
        // Boat Hull
        const hullGeometry = new THREE.BoxGeometry(3, 1, 7);
        const hullMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xbb8866, 
            map: woodTexture,
            roughness: 0.7
        });
        const hull = new THREE.Mesh(hullGeometry, hullMaterial);
        hull.position.y = 0.5;
        hull.castShadow = true;
        boatGroup.add(hull);
        
        // Boat Seat
        const seatGeometry = new THREE.BoxGeometry(2.5, 0.2, 1);
        const seat = new THREE.Mesh(seatGeometry, hullMaterial);
        seat.position.set(0, 1, -2);
        boatGroup.add(seat);
        
        // Boat Details - Rails
        const railGeometry = new THREE.CylinderGeometry(0.05, 0.05, 6.8);
        const railMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd });
        
        const leftRail = new THREE.Mesh(railGeometry, railMaterial);
        leftRail.rotation.x = Math.PI/2;
        leftRail.position.set(-1.4, 1.2, 0);
        boatGroup.add(leftRail);
        
        const rightRail = new THREE.Mesh(railGeometry, railMaterial);
        rightRail.rotation.x = Math.PI/2;
        rightRail.position.set(1.4, 1.2, 0);
        boatGroup.add(rightRail);
        
        // Water ripple effect around boat (instead of splash/wake)
        const rippleGeometry = new THREE.RingGeometry(1, 5, 32);
        const rippleMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        const ripple = new THREE.Mesh(rippleGeometry, rippleMaterial);
        ripple.rotation.x = -Math.PI/2;
        ripple.position.y = -0.1; // Just below water surface
        boatGroup.add(ripple);
        
        // Position boat precisely at water level for floating effect
        boatGroup.position.y = 0;
        
        return boatGroup;
    };
    
    const boat = createBoat();
    scene.add(boat);

    // Fisherman with more detail
    const createFisherman = () => {
        const fishermanGroup = new THREE.Group();
        
        // Head
        const headGeometry = new THREE.SphereGeometry(0.3);
        const skinMaterial = new THREE.MeshStandardMaterial({ color: 0xe0ac69 });
        const head = new THREE.Mesh(headGeometry, skinMaterial);
        head.position.y = 0.3;
        fishermanGroup.add(head);
        
        // Body
        const bodyGeometry = new THREE.CylinderGeometry(0.2, 0.3, 0.8);
        const clothesMaterial = new THREE.MeshStandardMaterial({ color: 0x3b5998 });
        const body = new THREE.Mesh(bodyGeometry, clothesMaterial);
        body.position.y = -0.4;
        fishermanGroup.add(body);
        
        // Hat
        const hatGeometry = new THREE.ConeGeometry(0.35, 0.3);
        const hatMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        const hat = new THREE.Mesh(hatGeometry, hatMaterial);
        hat.position.y = 0.6;
        fishermanGroup.add(hat);
        
        // Arms
        const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.6);
        
        const leftArm = new THREE.Mesh(armGeometry, skinMaterial);
        leftArm.position.set(-0.4, -0.3, 0);
        leftArm.rotation.z = -Math.PI/4;
        fishermanGroup.add(leftArm);
        
        const rightArm = new THREE.Mesh(armGeometry, skinMaterial);
        rightArm.position.set(0.4, -0.3, 0);
        rightArm.rotation.z = Math.PI/4;
        fishermanGroup.add(rightArm);
        
        // Make the entire fisherman clickable
        fishermanGroup.userData.clickable = true;
        
        // Position fisherman in the boat
        fishermanGroup.position.set(0, 1.5, -2);
        return fishermanGroup;
    };
    
    const fisherman = createFisherman();
    boat.add(fisherman); // Add fisherman to boat so he moves with it

    // Fishing Rod
    const rodGeometry = new THREE.CylinderGeometry(0.02, 0.01, 3);
    const rodMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
    const fishingRod = new THREE.Mesh(rodGeometry, rodMaterial);
    fishingRod.position.set(0.2, 0.2, 0.5);
    fishingRod.rotation.z = -Math.PI/4;
    fisherman.add(fishingRod); // Add to fisherman so it moves with him

    // Fishing Line & Bait
    const lineStartPosition = new THREE.Vector3(0.9, -0.3, 0.5);
    const lineEndPosition = new THREE.Vector3(0.9, -1.5, 0.5);
    
    const fishingLine = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([lineStartPosition, lineEndPosition]),
        new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 })
    );
    fisherman.add(fishingLine);

    const bait = new THREE.Mesh(
        new THREE.SphereGeometry(0.15),
        new THREE.MeshStandardMaterial({ color: 0xff9900, metalness: 0.5, roughness: 0.2 })
    );
    bait.position.copy(lineEndPosition);
    bait.castShadow = true;
    fisherman.add(bait);

    // Depth Markers - Add depth markers every 100m until 1km
    const createDepthMarkers = () => {
        const markersGroup = new THREE.Group();
        
        for (let depth = 100; depth <= 1000; depth += 100) {
            // Create marker text using sprite
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = 'rgba(0, 0, 0, 0.7)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = 'bold 32px Arial';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(`${depth}m`, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            
            const material = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true
            });
            
            const sprite = new THREE.Sprite(material);
            sprite.position.set(-20, -depth, 0); // Position at appropriate depth
            sprite.scale.set(10, 2.5, 1);
            
            // Add depth line
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-25, -depth, 0),
                new THREE.Vector3(25, -depth, 0)
            ]);
            
            const line = new THREE.Line(
                lineGeometry,
                new THREE.LineBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.5
                })
            );
            
            markersGroup.add(sprite);
            markersGroup.add(line);
        }
        
        return markersGroup;
    };
    
    const depthMarkers = createDepthMarkers();
    scene.add(depthMarkers);

    // Enhanced Fish and added descriptions for tooltips
    const fishSpecies = [
        {
            name: "Great White Shark",
            scientificName: "Carcharodon carcharias",
            depth: 800,
            color: 0x808080,
            size: 3,
            description: "The great white shark is a powerful apex predator that can grow up to 6m in length. They are known for their impressive hunting abilities and can detect prey through electrical impulses.",
            model: "3D"
        },
        {
            name: "Blue Marlin",
            scientificName: "Makaira nigricans",
            depth: 200,
            color: 0x0066cc,
            size: 2.2,
            description: "The blue marlin is one of the largest and fastest fish in the ocean, reaching speeds of 80 km/h. Its distinctive bill is used to slash through schools of fish, stunning its prey.",
            model: "3D"
        },
        {
            name: "Deep Sea Anglerfish",
            scientificName: "Melanocetus johnsonii",
            depth: 900,
            color: 0x333333,
            size: 0.8,
            description: "The fearsome anglerfish dwells in the deep ocean. Female anglerfish have a glowing lure that attracts prey in the dark depths. They can expand their jaws to consume prey larger than themselves.",
            model: "3D"
        },
        {
            name: "Clownfish",
            scientificName: "Amphiprion ocellaris",
            depth: 50,
            color: 0xff7700,
            size: 0.5,
            description: "Clownfish live among the tentacles of sea anemones in a symbiotic relationship. They're protected by mucus that prevents the anemone's stinging cells from firing.",
            model: "3D"
        },
        {
            name: "Giant Squid",
            scientificName: "Architeuthis dux",
            depth: 700,
            color: 0xcc3300,
            size: 4,
            description: "The elusive giant squid is one of the largest invertebrates, reaching lengths of up to 13m. They have the largest eyes in the animal kingdom and hunt using their two long feeding tentacles.",
            model: "3D"
        }
    ];

    // Create specialized Fish Models (both 2D and 3D)
    const createSpecialFish = (fishData) => {
        const fishGroup = new THREE.Group();
        
        if (fishData.model === "3D") {
            // 3D Fish Model
            let bodyGeometry, bodyMaterial;
            
            if (fishData.name === "Great White Shark") {
                // Shark shape
                const points = [];
                for (let i = 0; i < 10; i++) {
                    const t = i / 9;
                    const radius = 0.3 * (1 - t * 0.8);
                    points.push(new THREE.Vector3(t * fishData.size - fishData.size/2, Math.sin(t * Math.PI) * radius, 0));
                }
                
                bodyGeometry = new THREE.LatheGeometry(points, 20);
                bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: fishData.color,
                    metalness: 0.2,
                    roughness: 0.8
                });
                
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI/2;
                fishGroup.add(body);
                
                // Shark fins
                const finGeometry = new THREE.ConeGeometry(0.3, 0.6, 3);
                const fin = new THREE.Mesh(finGeometry, bodyMaterial);
                fin.rotation.z = -Math.PI/2;
                fin.position.set(0, 0.4, 0);
                fishGroup.add(fin);
                
                // Tail fin
                const tailGeometry = new THREE.ConeGeometry(0.7, 1, 2);
                tailGeometry.rotateZ(Math.PI/2);
                const tail = new THREE.Mesh(tailGeometry, bodyMaterial);
                tail.position.set(-fishData.size/2 - 0.3, 0, 0);
                fishGroup.add(tail);
                
            } else if (fishData.name === "Blue Marlin") {
                // Marlin body
                bodyGeometry = new THREE.ConeGeometry(0.3, fishData.size, 16);
                bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: fishData.color,
                    metalness: 0.5,
                    roughness: 0.5
                });
                
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI/2;
                fishGroup.add(body);
                
                // Marlin bill
                const billGeometry = new THREE.CylinderGeometry(0.02, 0.05, fishData.size/2);
                const bill = new THREE.Mesh(billGeometry, bodyMaterial);
                bill.rotation.z = Math.PI/2;
                bill.position.set(fishData.size/2 + fishData.size/4, 0, 0);
                fishGroup.add(bill);
                
                // Marlin fin
                const finGeometry = new THREE.PlaneGeometry(fishData.size/2, 0.7);
                const finMaterial = new THREE.MeshStandardMaterial({ 
                    color: fishData.color,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                
                const fin = new THREE.Mesh(finGeometry, finMaterial);
                fin.rotation.y = Math.PI/2;
                fin.position.set(0, 0.5, 0);
                fishGroup.add(fin);
                
            } else if (fishData.name === "Deep Sea Anglerfish") {
                // Anglerfish body
                bodyGeometry = new THREE.SphereGeometry(fishData.size/2, 16, 16);
                bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: fishData.color,
                    metalness: 0.2,
                    roughness: 0.9
                });
                
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                fishGroup.add(body);
                
                // Anglerfish teeth
                const jawGeometry = new THREE.TorusGeometry(fishData.size/3, fishData.size/15, 8, 14, Math.PI);
                const jawMaterial = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
                
                const jaw = new THREE.Mesh(jawGeometry, jawMaterial);
                jaw.position.set(fishData.size/3, -fishData.size/4, 0);
                jaw.rotation.z = Math.PI/2;
                fishGroup.add(jaw);
                
                // Anglerfish lure
                const lureStickGeometry = new THREE.CylinderGeometry(0.03, 0.03, fishData.size/2);
                const lureStick = new THREE.Mesh(lureStickGeometry, bodyMaterial);
                lureStick.position.set(0, fishData.size/2, 0);
                lureStick.rotation.x = -Math.PI/4;
                fishGroup.add(lureStick);
                
                const lureGeometry = new THREE.SphereGeometry(fishData.size/10);
                const lureMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 1
                });
                
                const lure = new THREE.Mesh(lureGeometry, lureMaterial);
                lure.position.set(0, fishData.size, 0);
                fishGroup.add(lure);
                
            } else if (fishData.name === "Clownfish") {
                // Clownfish body
                bodyGeometry = new THREE.ConeGeometry(0.2, fishData.size, 16);
                bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: fishData.color,
                    metalness: 0.3,
                    roughness: 0.7
                });
                
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI/2;
                fishGroup.add(body);
                
                // Clownfish stripes
                const stripeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
                
                for (let i = 0; i < 3; i++) {
                    const stripeGeometry = new THREE.TorusGeometry(0.2, 0.03, 8, 16, Math.PI);
                    const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                    stripe.position.set(-0.1 + i * 0.2, 0, 0);
                    stripe.rotation.x = Math.PI/2;
                    fishGroup.add(stripe);
                }
                
            } else if (fishData.name === "Giant Squid") {
                // Squid head
                bodyGeometry = new THREE.ConeGeometry(fishData.size/4, fishData.size/2, 16);
                bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: fishData.color,
                    metalness: 0.3,
                    roughness: 0.8
                });
                
                const head = new THREE.Mesh(bodyGeometry, bodyMaterial);
                head.rotation.z = -Math.PI/2;
                fishGroup.add(head);
                
                // Squid tentacles
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    
                    const points = [];
                    for (let j = 0; j < 10; j++) {
                        const segmentLength = fishData.size / 20;
                        const x = -fishData.size/4 - j * segmentLength;
                        const y = Math.sin(j * 0.5) * 0.2;
                        points.push(new THREE.Vector3(x, y, 0));
                    }
                    
                    const tentacleGeometry = new THREE.BufferGeometry().setFromPoints(points);
                    const tentacle = new THREE.Line(tentacleGeometry, new THREE.LineBasicMaterial({ color: fishData.color }));
                    
                    tentacle.rotation.y = angle;
                    fishGroup.add(tentacle);
                }
                
                // Two longer feeding tentacles
                for (let i = 0; i < 2; i++) {
                    const points = [];
                    for (let j = 0; j < 15; j++) {
                        const segmentLength = fishData.size / 15;
                        const x = -fishData.size/4 - j * segmentLength;
                        const y = Math.sin(j * 0.3) * 0.3 * (i === 0 ? 1 : -1);
                        points.push(new THREE.Vector3(x, y, 0));
                    }
                    
                    const tentacleGeometry = new THREE.BufferGeometry().setFromPoints(points);
                    const tentacle = new THREE.Line(tentacleGeometry, new THREE.LineBasicMaterial({ color: fishData.color }));
                    
                    tentacle.rotation.y = i * Math.PI;
                    fishGroup.add(tentacle);
                }
            }
            
            // Add eyes to all fish
            const eyeGeometry = new THREE.SphereGeometry(fishData.size/15);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            const eyeL = new THREE.Mesh(eyeGeometry, eyeMaterial);
            eyeL.position.set(fishData.size/4, fishData.size/10, fishData.size/8);
            fishGroup.add(eyeL);
            
            const eyeR = new THREE.Mesh(eyeGeometry, eyeMaterial);
            eyeR.position.set(fishData.size/4, fishData.size/10, -fishData.size/8);
            fishGroup.add(eyeR);
            
            // Pupil
            const pupilGeometry = new THREE.SphereGeometry(fishData.size/30);
            const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            
            const pupilL = new THREE.Mesh(pupilGeometry, pupilMaterial);
            pupilL.position.set(fishData.size/4 + fishData.size/20, fishData.size/10, fishData.size/8);
            fishGroup.add(pupilL);
            
            const pupilR = new THREE.Mesh(pupilGeometry, pupilMaterial);
            pupilR.position.set(fishData.size/4 + fishData.size/20, fishData.size/10, -fishData.size/8);
            fishGroup.add(pupilR);
        }
        
        // Store fish information for tooltip
        fishGroup.userData.fishInfo = fishData;
        fishGroup.userData.isSpecialFish = true;
        
        // Position fish at correct depth
        fishGroup.position.set(
            (Math.random() - 0.5) * 30,
            -fishData.depth,
            (Math.random() - 0.5) * 30
        );
        
        // Add basic animation parameters
        fishGroup.userData.animation = {
            speed: 0.003 + Math.random() * 0.005,
            amplitude: 5 + Math.random() * 5,
            originalX: fishGroup.position.x,
            originalZ: fishGroup.position.z,
            phase: Math.random() * Math.PI * 2
        };
        
        return fishGroup;
    };

    // Create all the special fish and add them to the scene
    const specialFishes = [];
    fishSpecies.forEach(fishData => {
        const fish = createSpecialFish(fishData);
        scene.add(fish);
        specialFishes.push(fish);
    });

    // Create a school of generic fish at different depths
    const genericFish = [];
    const createGenericFishSchool = (count, minDepth, maxDepth) => {
        for (let i = 0; i < count; i++) {
            const depth = minDepth + Math.random() * (maxDepth - minDepth);
            const size = 0.2 + Math.random() * 0.3;
            
            // Simple fish shape
            const fishGroup = new THREE.Group();
            
            // Fish body
            const bodyGeometry = new THREE.ConeGeometry(size/2, size, 8);
            const fishColor = new THREE.Color(
                0.4 + Math.random() * 0.6,
                0.4 + Math.random() * 0.6,
                0.4 + Math.random() * 0.6
            );
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: fishColor,
                metalness: 0.3,
                roughness: 0.7 
            });
            
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.z = Math.PI/2;
            fishGroup.add(body);
            
            // Fish tail
            const tailGeometry = new THREE.ConeGeometry(size/2, size/2, 4);
            tailGeometry.rotateZ(Math.PI);
            const tail = new THREE.Mesh(tailGeometry, bodyMaterial);
            tail.position.set(-size/2 - size/4, 0, 0);
            fishGroup.add(tail);
            
            // Position fish
            fishGroup.position.set(
                (Math.random() - 0.5) * 60,
                -depth,
                (Math.random() - 0.5) * 60
            );
            
            // Add animation parameters
            fishGroup.userData.animation = {
                speed: 0.01 + Math.random() * 0.02,
                amplitude: 10 + Math.random() * 20,
                originalX: fishGroup.position.x,
                originalZ: fishGroup.position.z,
                phase: Math.random() * Math.PI * 2,
                schoolIndex: Math.floor(i / 5) // Group fish into small schools
            };
            
            scene.add(fishGroup);
            genericFish.push(fishGroup);
        }
    };
    
    // Create various fish schools at different depths
    createGenericFishSchool(30, 20, 200);   // Surface fish
    createGenericFishSchool(20, 200, 500);  // Mid-depth fish
    createGenericFishSchool(10, 500, 900);  // Deep fish

    // Add some marine plants and corals
    const createSeaPlants = () => {
        const plantsGroup = new THREE.Group();
        
        // Create seaweed at different depths
        for (let i = 0; i < 20; i++) {
            const height = 2 + Math.random() * 3;
            const segments = Math.floor(height * 2);
            
            const points = [];
            for (let j = 0; j <= segments; j++) {
                const y = (j / segments) * height;
                const waveOffset = Math.sin(j * 0.5) * 0.3;
                points.push(new THREE.Vector3(waveOffset, y, 0));
            }
            
            const seaweedGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const seaweedMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00cc66,
                linewidth: 2
            });
            
            const seaweed = new THREE.Line(seaweedGeometry, seaweedMaterial);
            
            // Position seaweed on the ocean floor
            const x = (Math.random() - 0.5) * 100;
            const z = (Math.random() - 0.5) * 100;
            seaweed.position.set(x, -1000, z);
            
            plantsGroup.add(seaweed);
        }
        
        // Create coral structures
        for (let i = 0; i < 15; i++) {
            const coralSize = 1 + Math.random() * 2;
            
            // Choose a coral type randomly
            const coralType = Math.floor(Math.random() * 3);
            let coralGeometry;
            
            if (coralType === 0) {
                // Brain coral
                coralGeometry = new THREE.SphereGeometry(coralSize, 12, 12);
            } else if (coralType === 1) {
                // Branch coral
                coralGeometry = new THREE.CylinderGeometry(0, coralSize/2, coralSize, 8);
            } else {
                // Table coral
                coralGeometry = new THREE.CylinderGeometry(coralSize, coralSize/2, coralSize/2, 8);
            }
            
            // Random coral color
            const coralColor = new THREE.Color(
                0.8 + Math.random() * 0.2,
                0.3 + Math.random() * 0.4,
                0.3 + Math.random() * 0.4
            );
            
            const coralMaterial = new THREE.MeshStandardMaterial({ 
                color: coralColor,
                metalness: 0.1,
                roughness: 0.8
            });
            
            const coral = new THREE.Mesh(coralGeometry, coralMaterial);
            
            // Position coral on the ocean floor
            const x = (Math.random() - 0.5) * 100;
            const z = (Math.random() - 0.5) * 100;
            coral.position.set(x, -999 + coralSize/2, z);
            
            plantsGroup.add(coral);
        }
        
        return plantsGroup;
    };
    
    const seaPlants = createSeaPlants();
    scene.add(seaPlants);

    // Add shipwreck on the ocean floor
    const createShipwreck = () => {
        const wreckGroup = new THREE.Group();
        
        // Ship hull (broken)
        const hullGeometry = new THREE.BoxGeometry(8, 3, 20);
        const hullMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x8B4513,
            roughness: 1,
            metalness: 0
        });
        
        const hull = new THREE.Mesh(hullGeometry, hullMaterial);
        hull.rotation.z = Math.PI / 6; // Tilt the wreck
        wreckGroup.add(hull);
        
        // Add some broken planks
        for (let i = 0; i < 10; i++) {
            const plankGeometry = new THREE.BoxGeometry(0.4, 0.2, 2 + Math.random() * 4);
            const plank = new THREE.Mesh(plankGeometry, hullMaterial);
            
            // Random position around the hull
            plank.position.set(
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 15
            );
            
            // Random rotation
            plank.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            
            wreckGroup.add(plank);
        }
        
        // Add a broken mast
        const mastGeometry = new THREE.CylinderGeometry(0.4, 0.4, 12);
        const mast = new THREE.Mesh(mastGeometry, hullMaterial);
        mast.position.set(0, 4, 0);
        mast.rotation.z = Math.PI / 3; // Fallen mast
        wreckGroup.add(mast);
        
        // Add a treasure chest
        const chestGroup = new THREE.Group();
        
        const chestBaseGeometry = new THREE.BoxGeometry(2, 1.2, 1.2);
        const chestMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x8B4513, 
            roughness: 0.7 
        });
        const chestBase = new THREE.Mesh(chestBaseGeometry, chestMaterial);
        chestGroup.add(chestBase);
        
        const chestLidGeometry = new THREE.BoxGeometry(2, 0.4, 1.4);
        const chestLid = new THREE.Mesh(chestLidGeometry, chestMaterial);
        chestLid.position.set(0, 0.8, -0.1);
        chestLid.rotation.x = Math.PI / 4; // Partially open
        chestGroup.add(chestLid);
        
        // Add golden coins spilling out
        const coinGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.02, 16);
        const coinMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xFFD700,
            metalness: 0.8,
            roughness: 0.2
        });
        
        for (let i = 0; i < 20; i++) {
            const coin = new THREE.Mesh(coinGeometry, coinMaterial);
            coin.position.set(
                (Math.random() - 0.5) * 2,
                Math.random() * 0.5,
                -0.8 - Math.random() * 1.5
            );
            
            coin.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            
            chestGroup.add(coin);
        }
        
        chestGroup.position.set(5, -1, 8);
        wreckGroup.add(chestGroup);
        
        // Position the entire wreck on the ocean floor
        wreckGroup.position.set(0, -995, 0);
        
        return wreckGroup;
    };
    
    const shipwreck = createShipwreck();
    scene.add(shipwreck);

    // Camera setup
    camera.position.set(0, 5, 10);
    camera.lookAt(0, 0, 0);

    // Scroll to dive behavior
    let currentDepth = 0;
    document.addEventListener('scroll', () => {
        const scrollY = window.scrollY;
        const maxDepth = 1000;
        const scrollFactor = maxDepth / (document.body.scrollHeight - window.innerHeight);
        
        currentDepth = Math.min(scrollY * scrollFactor, maxDepth);
        
        // Update the depth marker text
        depthMarker.textContent = `Current Depth: ${Math.round(currentDepth)}m`;
        
        // Update camera position based on scroll
        if (currentDepth < 5) {
            // Keep the camera above water until we're ready to dive
            camera.position.y = 5 - currentDepth * 0.5;
        } else {
            // Move below the surface
            camera.position.y = 2.5 - currentDepth;
        }
        
        // Change lighting and fog as we go deeper
        const depthFactor = currentDepth / maxDepth;
        
        // Decrease ambient light with depth
        ambientLight.intensity = 0.5 - depthFactor * 0.3;
        
        // Decrease directional light with depth
        directionalLight.intensity = 1 - depthFactor * 0.8;
        
        // Change fog density and color with depth
        scene.fog.density = 0.04 + depthFactor * 0.04;
        
        // Shift fog color from blue to dark blue to almost black
        const fogColor = new THREE.Color(
            0.12 - depthFactor * 0.11,
            0.23 - depthFactor * 0.18,
            0.37 - depthFactor * 0.25
        );
        scene.fog.color.copy(fogColor);
        renderer.setClearColor(scene.fog.color);
    });

    // Handle window resize
    window.addEventListener('resize', () => {
        const newWidth = window.innerWidth;
        const newHeight = window.innerHeight;
        
        camera.aspect = newWidth / newHeight;
        camera.updateProjectionMatrix();
        
        renderer.setSize(newWidth, newHeight);
    });

    // Mouse move for tooltip
    window.addEventListener('mousemove', (event) => {
        // Calculate mouse position in normalized device coordinates
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
        // Update tooltip position
        tooltip.style.left = event.clientX + 15 + 'px';
        tooltip.style.top = event.clientY + 15 + 'px';
    });

    // Click handler for fishing
    let isFishing = false;
    let caughtFish = null;
    
    window.addEventListener('click', (event) => {
        // Calculate mouse position in normalized device coordinates
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
        // Check if the fisherman was clicked
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);
        
        for (let i = 0; i < intersects.length; i++) {
            let object = intersects[i].object;
            
            // Check if the clicked object or any of its parents is the fisherman
            while (object && !object.userData.clickable) {
                object = object.parent;
            }
            
            if (object && object.userData.clickable) {
                // Toggle fishing state
                isFishing = !isFishing;
                
                if (isFishing) {
                    // Cast fishing line animation
                    const baitDepth = Math.min(currentDepth + 30, 900);
                    
                    // Animate fishing rod bend
                    gsap.to(fishingRod.rotation, {
                        z: -Math.PI/3,
                        duration: 0.5
                    });
                    
                    // Animate fishing line and bait going down
                    gsap.to(fishingLine.geometry.attributes.position.array, {
                        [3]: 0.9, // End X
                        [4]: -baitDepth + boat.position.y, // End Y
                        [5]: 0.5, // End Z
                        duration: 3,
                        onUpdate: () => {
                            fishingLine.geometry.attributes.position.needsUpdate = true;
                        },
                        onComplete: () => {
                            // After the bait is at depth, check if any fish are nearby
                            checkForFishNearBait(baitDepth);
                        }
                    });
                    
                    // Move bait with line
                    gsap.to(bait.position, {
                        y: -baitDepth + boat.position.y + fisherman.position.y,
                        duration: 3
                    });
                } else {
                    // Reel in the line
                    gsap.to(fishingRod.rotation, {
                        z: -Math.PI/4,
                        duration: 0.5
                    });
                    
                    gsap.to(fishingLine.geometry.attributes.position.array, {
                        [3]: lineEndPosition.x, // original X
                        [4]: lineEndPosition.y, // original Y
                        [5]: lineEndPosition.z, // original Z
                        duration: 1,
                        onUpdate: () => {
                            fishingLine.geometry.attributes.position.needsUpdate = true;
                        }
                    });
                    
                    // Move bait back with line
                    gsap.to(bait.position, {
                        x: lineEndPosition.x,
                        y: lineEndPosition.y,
                        z: lineEndPosition.z,
                        duration: 1
                    });
                    
                    // If a fish was caught, release it
                    if (caughtFish) {
                        caughtFish = null;
                    }
                }
                
                break;
            }
        }
    });

    // Check if any fish are near the bait
    const checkForFishNearBait = (baitDepth) => {
        if (!isFishing) return;
        
        // Get bait world position
        const baitWorldPos = new THREE.Vector3();
        bait.getWorldPosition(baitWorldPos);
        
        // Check special fish first (they're more interesting to catch)
        let nearestFish = null;
        let nearestDistance = 10; // Maximum distance to catch a fish
        
        // Check special fish
        for (const fish of specialFishes) {
            const fishDepth = -fish.position.y;
            
            // Check if fish is within depth range
            if (Math.abs(fishDepth - baitDepth) < 50) {
                const distance = fish.position.distanceTo(baitWorldPos);
                
                if (distance < nearestDistance) {
                    nearestDistance = distance;
                    nearestFish = fish;
                }
            }
        }
        
        // If no special fish found, check generic fish
        if (!nearestFish) {
            for (const fish of genericFish) {
                const fishDepth = -fish.position.y;
                
                // Check if fish is within depth range
                if (Math.abs(fishDepth - baitDepth) < 30) {
                    const distance = fish.position.distanceTo(baitWorldPos);
                    
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestFish = fish;
                    }
                }
            }
        }
        
        // If a fish is found, catch it!
        if (nearestFish && Math.random() > 0.5) { // 50% chance to catch
            caughtFish = nearestFish;
            
            // Animate the fishing rod bend more (fish pulling)
            gsap.to(fishingRod.rotation, {
                z: -Math.PI/2.5,
                duration: 0.3,
                yoyo: true,
                repeat: 3
            });
            
            // Display caught fish info
            let fishInfo;
            if (nearestFish.userData.isSpecialFish) {
                fishInfo = nearestFish.userData.fishInfo;
                alert(`You caught a ${fishInfo.name}!\n\n${fishInfo.description}`);
            } else {
                alert("You caught a fish!");
            }
            
            // Reset fishing after catch
            isFishing = false;
            
            // Reel in the line
            gsap.to(fishingRod.rotation, {
                z: -Math.PI/4,
                duration: 0.5,
                delay: 1
            });
            
            gsap.to(fishingLine.geometry.attributes.position.array, {
                [3]: lineEndPosition.x,
                [4]: lineEndPosition.y,
                [5]: lineEndPosition.z,
                duration: 1,
                delay: 1,
                onUpdate: () => {
                    fishingLine.geometry.attributes.position.needsUpdate = true;
                }
            });
            
            // Move bait back with line
            gsap.to(bait.position, {
                x: lineEndPosition.x,
                y: lineEndPosition.y,
                z: lineEndPosition.z,
                duration: 1,
                delay: 1
            });
            
            caughtFish = null;
        } else {
            // No fish caught, try again in a few seconds
            setTimeout(() => {
                if (isFishing) {
                    checkForFishNearBait(baitDepth);
                }
            }, 3000);
        }
    };

    // Animation loop
    const animate = () => {
        requestAnimationFrame(animate);
        
        // Animate water surface
        const time = Date.now() * 0.001;
        
        // Animate surface waves
        if (surfaceVertices) {
            for (let i = 0; i < surfaceVertices.length; i += 3) {
                const x = surfaceGeometry.attributes.position.getX(i/3);
                const z = surfaceGeometry.attributes.position.getZ(i/3);
                
                // Create wave pattern
                const y = Math.sin(x * 0.5 + time) * Math.cos(z * 0.5 + time) * 0.5;
                
                surfaceVertices[i + 1] = y;
            }
            
            surfaceGeometry.attributes.position.needsUpdate = true;
            surfaceGeometry.computeVertexNormals();
        }
        
        // Animate normal map on the water surface
        waterTexture.offset.x = time * 0.05;
        waterTexture.offset.y = time * 0.05;
        
        // Boat floating effect - gentle bobbing
        if (boat) {
            boat.position.y = Math.sin(time * 0.5) * 0.1;
            boat.rotation.x = Math.sin(time * 0.5) * 0.02;
            boat.rotation.z = Math.sin(time * 0.7) * 0.01;
        }
        
        // Animate fish
        [...specialFishes, ...genericFish].forEach(fish => {
            if (fish === caughtFish) return; // Skip animation for caught fish
            
            const animation = fish.userData.animation;
            
            // Calculate new position in a circular pattern with some randomness
            const angle = time * animation.speed + animation.phase;
            
            // For schooling fish, add some coherence in movement
            let schoolOffset = { x: 0, z: 0 };
            if (fish.userData.animation.schoolIndex !== undefined) {
                const schoolIndex = fish.userData.animation.schoolIndex;
                schoolOffset.x = Math.sin(time * 0.1 + schoolIndex) * 5;
                schoolOffset.z = Math.cos(time * 0.1 + schoolIndex) * 5;
            }
            
            fish.position.x = animation.originalX + Math.sin(angle) * animation.amplitude + schoolOffset.x;
            fish.position.z = animation.originalZ + Math.cos(angle) * animation.amplitude + schoolOffset.z;
            
            // Orient fish in the direction of movement
            const direction = new THREE.Vector2(
                fish.position.x - (animation.originalX + schoolOffset.x + Math.sin(angle - 0.01) * animation.amplitude),
                fish.position.z - (animation.originalZ + schoolOffset.z + Math.cos(angle - 0.01) * animation.amplitude)
            );
            
            if (direction.length() > 0.001) {
                const angle = Math.atan2(direction.y, direction.x);
                fish.rotation.y = angle + Math.PI/2;
            }
        });
        
        // Tooltip raycasting
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);
        
        let hoveredFish = null;
        
        for (let i = 0; i < intersects.length; i++) {
            let object = intersects[i].object;
            
            // Traverse up to find parent with fish info
            while (object && !object.userData.fishInfo) {
                object = object.parent;
            }
            
            if (object && object.userData.fishInfo) {
                hoveredFish = object;
                break;
            }
        }
        
        if (hoveredFish) {
            const fishInfo = hoveredFish.userData.fishInfo;
            tooltip.innerHTML = `
                <strong>${fishInfo.name}</strong><br>
                <em>${fishInfo.scientificName}</em><br>
                Depth: ~${fishInfo.depth}m<br>
                <small>${fishInfo.description}</small>
            `;
            tooltip.style.display = 'block';
        } else {
            tooltip.style.display = 'none';
        }
        
        renderer.render(scene, camera);
    };
    
    animate();
</script>
</body>
</html>